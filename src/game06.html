<!DOCTYPE html>
<html>
  <head>
    <title>game06</title>
    <style>
      button.active {
        background-color: #ccc;
      }
      canvas {
        border: 1px solid black;
      }
      #canvas1 {
        position: relative;
      }
    </style>
  </head>
  <body>
    <p>
      <canvas id="canvas1" width="510" height="300"></canvas>
    </p>
    <script src="engine.js"></script>
    <script src="util.js"></script>
    <script language="JavaScript">
      // https://m.blog.naver.com/kiseop91/221855589754
      // https://blog.unity.com/kr/technology/on-dots-entity-component-system
      // https://everyday-devup.tistory.com/68
      // https://javart.tistory.com/80
      var pointer = { x: 0, y: 0 };
      var tileSize = 30;
      var selectIdx = -1;

      var wallMeta = [
        "11111111111111111",
        "10000000000000001",
        "10000000000000001",
        "10000000000000003",
        "20000000000000003",
        "20000000000000003",
        "10000000000000003",
        "10000000000000001",
        "10000000000000001",
        "11111111111111111",
      ];

      function setWall(x, y, val) {
        var col = wallMeta[y];
        wallMeta[y] = col.substr(0, x) + val + col.substr(x + val.length);
      }

      function isWall(x, y, val) {
        var col = wallMeta[y];
        return val === col.charAt(x);
      }

      function findAll(compare) {
        var ret = [];
        for (var i = 0; i < wallMeta.length; ++i) {
          var col = wallMeta[i];
          for (var j = 0; j < col.length; ++j) {
            compare(col.charAt(j)) && ret.push({ x: j, y: i });
          }
        }
        return ret;
      }

      var exits = findAll(function (it) {
        return it === "3";
      });

      var AreaWidth;
      var AreaHeight;

      var enermies = [];
      function removeEnermy(obj) {
        var idx = enermies.indexOf(obj);
        ~idx && enermies.splice(idx, 1);
      }

      GameWorld.Entity(
        "Enermy",
        {
          size: 14,
          created: function (props) {
            // Object.assign(this, ctx);
            this.tick = tileSize / 2;
            this.speed = 100;
            this.pt = {
              x: props.pt.x * tileSize + this.tick,
              y: props.pt.y * tileSize + this.tick,
            };
            this.updateRoute();
            this.nextRoute();
          },
          step: function (dt) {
            try {
              this.pt.x += this.direction.x * this.speed * dt;
              this.pt.y += this.direction.y * this.speed * dt;
              if (
                this.pt.x >= GameWorld.width ||
                this.pt.y >= GameWorld.height
              ) {
                removeEnermy(this);
                this.delete();
              }
              if (this.isArrived()) {
                this.nextRoute();
              }
            } catch (ex) {
              console.error(ex);
              removeEnermy(this);
              this.delete();
            }
          },
          updateRoute() {
            var pt = {
              x: Math.floor(this.pt.x / tileSize),
              y: Math.floor(this.pt.y / tileSize),
            };
            var route = searchExit(pt, exits, AreaWidth, AreaHeight);
            this.route = route.map(
              function (it) {
                return {
                  x: it.x * tileSize + this.tick,
                  y: it.y * tileSize + this.tick,
                };
              }.bind(this)
            );
            this.routeIdx = 0;
          },
          nextRoute() {
            this.routeIdx += 1;
            if (this.routeIdx >= this.route.length) return;
            var toPt = this.route[this.routeIdx];
            this.direction = {
              x: this.pt.x < toPt.x ? 1 : this.pt.x > toPt.x ? -1 : 0,
              y: this.pt.y < toPt.y ? 1 : this.pt.y > toPt.y ? -1 : 0,
            };
          },
          isArrived() {
            var toPt = this.route[this.routeIdx];
            if (this.route.length <= this.routeIdx) return false;
            var resultX = false,
              resultY = false;
            if (0 < this.direction.x) {
              resultX = this.pt.x >= toPt.x;
            } else if (0 > this.direction.x) {
              resultX = this.pt.x <= toPt.x;
            } else {
              resultX = true;
            }
            if (0 < this.direction.y) {
              resultY = this.pt.y >= toPt.y;
            } else if (0 > this.direction.y) {
              resultY = this.pt.y <= toPt.y;
            } else {
              resultY = true;
            }
            if (resultX) {
              this.pt.x = toPt.x;
            }
            if (resultY) {
              this.pt.y = toPt.y;
            }
            return resultX && resultY;
          },
          paint: function (ctx) {
            // this.route &&
            //   this.route.forEach(
            //     function (it) {
            //       this.drawNum(ctx, it, it.index);
            //     }.bind(this)
            //   );
            GameUtils.diamond(ctx, this.pt, this.size, this.size, {
              fillStyle: "red",
            });
          },
          drawNum: function (ctx, pt, txtCenter, txtBL, txtBR) {
            GameUtils.text(
              ctx,
              {
                x: tileSize * pt.x + tileSize / 2,
                y: tileSize * pt.y + 11,
              },
              txtCenter,
              {
                font: "11px sans-serif",
                textAlign: "center",
                textBaseline: "middle",
                fillStyle: "black",
              }
            );
            undefined !== txtBL &&
              GameUtils.text(
                ctx,
                {
                  x: tileSize * pt.x + 3,
                  y: tileSize * pt.y + tileSize - 6,
                },
                txtBL,
                {
                  font: "9px sans-serif",
                  textAlign: "left",
                  textBaseline: "middle",
                  fillStyle: "black",
                }
              );
            undefined !== txtBR &&
              GameUtils.text(
                ctx,
                {
                  x: tileSize * pt.x + tileSize - 3,
                  y: tileSize * pt.y + tileSize - 6,
                },
                txtBR,
                {
                  font: "9px sans-serif",
                  textAlign: "right",
                  textBaseline: "middle",
                  fillStyle: "black",
                }
              );
            GameUtils.rect(
              ctx,
              { x: tileSize * pt.x, y: tileSize * pt.y },
              tileSize,
              tileSize,
              { strokeStyle: "black" }
            );
          },
        },
        { layer: 1 }
      );

      GameWorld.Entity("Wall", {
        step: function (dt) {
          this.ptnWall = [
            GameWorld.createPattern(5, 2, 3, "lightgray", "gray"),
            GameWorld.createPattern(5, 3, 1, "lightgray", "gray"),
            GameWorld.createPattern(5, 3, 1, "lightgray", "gray"),
          ];
        },
        paint: function (ctx) {
          for (var i = 0; i < wallMeta.length; ++i) {
            for (var j = 0; j < wallMeta[i].length; ++j) {
              this.drawWall(ctx, j, i, Number(wallMeta[i].charAt(j)));
            }
          }
        },
        drawWall: function (ctx, x, y, type) {
          if (!type) return;
          var wall = this.ptnWall[type - 1];
          if (!wall) return;
          GameUtils.fillRect(
            ctx,
            { x: x * tileSize, y: y * tileSize },
            tileSize,
            tileSize,
            {
              fillStyle: wall,
            }
          );
        },
      });
      function searchExit(entry, exits, width, height) {
        var working = new GameUtils.Heap(function (l, r) {
          return l.f - r.f;
        });
        var visitedIdx = [];
        var indes = [];
        var done;
        function indexOf(pt) {
          return pt.y * width + pt.x;
        }
        function h(pt) {
          var ret = exits.map(function (it) {
            return Math.abs(it.x - pt.x) + Math.abs(it.y - pt.y);
          });
          return Math.min.apply(null, ret);
        }
        var existIdxs = exits.map(function (it) {
          return indexOf(it);
        });
        let n = Object.assign({}, entry, {
          index: indexOf(entry),
          g: 0,
          order: 0,
          h: h(entry),
        });
        working.push(n);
        while (!working.empty()) {
          let n = working.pop();
          if (visitedIdx[n.index]) continue;
          visitedIdx[n.index] = true;
          if (~existIdxs.indexOf(n.index)) {
            working.clear();
            done = n;
            break;
          }
          let list = [
            { x: n.x + 1, y: n.y },
            { x: n.x - 1, y: n.y },
            { x: n.x, y: n.y + 1 },
            { x: n.x, y: n.y - 1 },
          ];
          list.forEach(function (it) {
            it.index = indexOf(it);
          });
          list = list
            .filter(function (it) {
              return 0 <= it.x && 0 <= it.y && it.x < width && it.y < height;
            })
            .filter(function (it) {
              return (
                "1" !== wallMeta[it.y].charAt(it.x) && !visitedIdx[it.index]
              );
            });
          list.forEach(function (it) {
            it.h = h(it);
            it.g = n.g + 1;
            it.f = it.h + it.g;
            it.parent = n;
            it.order = n.order + 1;
          });
          list.forEach(function (it) {
            let item = indes[it.index];
            if (!item || item.f > it.f) {
              indes[it.index] = it;
            }
            working.push(it);
          });
        }
        var ret = [];
        var next = done;
        while (next) {
          ret.unshift({ x: next.x, y: next.y, index: next.index });
          next = next.parent;
        }
        return ret;
      }
      var grid = 30;
      function applyGrid(val) {
        return Math.floor(val / grid) * grid + grid / 2;
      }

      function startup() {
        GameWorld.on("mousemove", function (ev) {
          pointer = { x: ev.offsetX, y: ev.offsetY };
        });
        GameWorld.on("mousedown", function (ev) {
          var pt = { x: ev.offsetX, y: ev.offsetY };

          var idxX = Math.floor(pt.x / tileSize);
          var idxY = Math.floor(pt.y / tileSize);

          // check wall
          if (isWall(idxX, idxY, "1")) return;

          // check Object
          // check route

          setWall(idxX, idxY, "1");
          enermies.forEach(function (it) {
            it.updateRoute();
          });
        });

        AreaWidth = Math.floor(GameWorld.width / tileSize);
        AreaHeight = Math.floor(GameWorld.height / tileSize);

        new GameWorld.Entity.Wall();
        setInterval(function () {
          enermies.push(new GameWorld.Entity.Enermy({ pt: { x: 0, y: 5 } }));
        }, 500);
      }

      window.addEventListener("load", function () {
        GameWorld.initialize("canvas1", startup);
      });
    </script>
  </body>
</html>
